{
  "id": "react-effects",
  "category": "react",
  "title": "useEffectによる副作用処理",
  "description": "useEffectフックの基本的な使い方、依存配列の役割、クリーンアップ関数、データフェッチングのパターンについて学びましょう",
  "content": "<div class=\"content-section\"><h2 class=\"section-title\">副作用（Side Effect）とは？</h2><p class=\"content-text\">Reactコンポーネントの主な役割は、Propsと状態に基づいてUIをレンダリングすることです。しかし、実際のアプリケーションでは、レンダリング以外の処理も必要になります。これを<strong>副作用（Side Effect）</strong>と呼びます。</p><p class=\"content-text\">副作用の例：</p><ul><li>APIからデータを取得する</li><li>DOMを直接操作する</li><li>タイマーを設定する（setTimeout, setInterval）</li><li>イベントリスナーを登録する</li><li>localStorageにデータを保存する</li><li>外部サービスとの通信</li></ul><div class=\"info-box\"><span class=\"info-box-icon\">💡</span><div class=\"info-box-content\"><div class=\"info-box-title\">なぜ「副作用」と呼ぶ？</div><div class=\"info-box-text\">コンポーネントの「主作用」はUIのレンダリングです。それ以外の外部システムとのやり取りは「副次的な作用」なので副作用と呼びます。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">useEffectの基本構文</h2><p class=\"content-text\"><strong>useEffect</strong>は、関数コンポーネントで副作用を実行するためのReact Hookです。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>import { useEffect, useState } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 基本的なuseEffect\n  useEffect(() => {\n    // この中に副作用の処理を書く\n    document.title = `カウント: ${count}`;\n  });\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;カウント: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;増やす&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></div></div><p class=\"content-text\">useEffectは<strong>レンダリング後</strong>に実行されます。これにより、DOMが更新された後に副作用を実行できます。</p></div><div class=\"content-section\"><h2 class=\"section-title\">依存配列（Dependency Array）</h2><p class=\"content-text\">useEffectの第2引数として<strong>依存配列</strong>を渡すことで、エフェクトの実行タイミングを制御できます。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// 1. 依存配列なし：毎回のレンダリング後に実行\nuseEffect(() => {\n  console.log('毎回実行される');\n});\n\n// 2. 空の依存配列：マウント時に1回だけ実行\nuseEffect(() => {\n  console.log('マウント時に1回だけ実行');\n}, []);\n\n// 3. 依存配列あり：指定した値が変わった時に実行\nuseEffect(() => {\n  console.log(`countが変わった: ${count}`);\n}, [count]);\n\n// 4. 複数の依存値\nuseEffect(() => {\n  console.log('countまたはnameが変わった');\n}, [count, name]);</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">⚠️</span><div class=\"info-box-content\"><div class=\"info-box-title\">依存配列のルール</div><div class=\"info-box-text\">エフェクト内で使用するすべての値（state、props、関数など）は依存配列に含める必要があります。ESLintのreact-hooks/exhaustive-depsルールで警告されます。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">クリーンアップ関数</h2><p class=\"content-text\">副作用によっては、コンポーネントがアンマウントされる時や、次のエフェクト実行前に<strong>後始末</strong>が必要な場合があります。useEffectから関数を返すことで、クリーンアップ処理を定義できます。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    // タイマーを設定\n    const intervalId = setInterval(() => {\n      setSeconds(prev => prev + 1);\n    }, 1000);\n\n    // クリーンアップ関数：タイマーを解除\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, []); // 空配列：マウント時に設定、アンマウント時に解除\n\n  return &lt;p&gt;経過時間: {seconds}秒&lt;/p&gt;;\n}</code></pre></div></div><p class=\"content-text\">クリーンアップが必要な典型的なケース：</p><ul><li>setInterval / setTimeout の解除</li><li>イベントリスナーの削除</li><li>WebSocket接続の切断</li><li>購読（subscription）の解除</li></ul><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function WindowSize() {\n  const [size, setSize] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    // イベントハンドラを定義\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    // 初期値を設定\n    handleResize();\n\n    // イベントリスナーを登録\n    window.addEventListener('resize', handleResize);\n\n    // クリーンアップ：イベントリスナーを削除\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return &lt;p&gt;ウィンドウサイズ: {size.width} x {size.height}&lt;/p&gt;;\n}</code></pre></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">データフェッチング</h2><p class=\"content-text\">useEffectの最も一般的な使用例の1つが、APIからのデータ取得です。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // async関数を内部で定義\n    async function fetchUser() {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const response = await fetch(`/api/users/${userId}`);\n        if (!response.ok) {\n          throw new Error('ユーザーが見つかりません');\n        }\n        const data = await response.json();\n        setUser(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchUser();\n  }, [userId]); // userIdが変わったら再取得\n\n  if (loading) return &lt;p&gt;読み込み中...&lt;/p&gt;;\n  if (error) return &lt;p&gt;エラー: {error}&lt;/p&gt;;\n  if (!user) return null;\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;{user.name}&lt;/h2&gt;\n      &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">⚠️</span><div class=\"info-box-content\"><div class=\"info-box-title\">async/awaitの注意点</div><div class=\"info-box-text\">useEffectのコールバック関数自体をasyncにすることはできません。代わりに、エフェクト内でasync関数を定義して呼び出します。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">レースコンディションの対処</h2><p class=\"content-text\">非同期処理では、古いリクエストの結果が新しいリクエストより後に届く<strong>レースコンディション</strong>が発生する可能性があります。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n\n  useEffect(() => {\n    // キャンセルフラグ\n    let cancelled = false;\n\n    async function search() {\n      const response = await fetch(`/api/search?q=${query}`);\n      const data = await response.json();\n      \n      // キャンセルされていなければ結果を設定\n      if (!cancelled) {\n        setResults(data);\n      }\n    }\n\n    search();\n\n    // クリーンアップ：このエフェクトの結果を無視\n    return () => {\n      cancelled = true;\n    };\n  }, [query]);\n\n  return (\n    &lt;ul&gt;\n      {results.map(item => (\n        &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}</code></pre></div></div><p class=\"content-text\">AbortControllerを使ったより堅牢な方法：</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>useEffect(() => {\n  const controller = new AbortController();\n\n  async function fetchData() {\n    try {\n      const response = await fetch(`/api/data/${id}`, {\n        signal: controller.signal\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (err) {\n      if (err.name !== 'AbortError') {\n        setError(err.message);\n      }\n    }\n  }\n\n  fetchData();\n\n  return () => {\n    controller.abort(); // リクエストをキャンセル\n  };\n}, [id]);</code></pre></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">無限ループの回避</h2><p class=\"content-text\">useEffectで最も注意すべきは<strong>無限ループ</strong>です。エフェクト内で依存配列に含まれる状態を更新すると、無限ループが発生します。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// ❌ 無限ループ！\nfunction BadExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setCount(count + 1); // countを更新 → 再レンダリング → エフェクト実行 → ...\n  }, [count]); // countに依存\n\n  return &lt;p&gt;{count}&lt;/p&gt;;\n}\n\n// ✅ 正しい例：条件付きで更新\nfunction GoodExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    if (count < 10) {\n      setCount(count + 1);\n    }\n  }, [count]);\n\n  return &lt;p&gt;{count}&lt;/p&gt;;\n}</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">💡</span><div class=\"info-box-content\"><div class=\"info-box-title\">無限ループを避けるコツ</div><div class=\"info-box-text\">1. 依存配列を正しく設定する<br/>2. エフェクト内での状態更新は条件付きにする<br/>3. オブジェクトや配列は毎回新しい参照になるので注意</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">useEffectの実行タイミング</h2><p class=\"content-text\">useEffectの実行タイミングを理解することは重要です：</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function LifecycleDemo() {\n  const [count, setCount] = useState(0);\n\n  console.log('1. レンダリング');\n\n  useEffect(() => {\n    console.log('3. エフェクト実行');\n    \n    return () => {\n      console.log('2. クリーンアップ（次のエフェクト前）');\n    };\n  }, [count]);\n\n  console.log('2. レンダリング完了');\n\n  return (\n    &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;\n      カウント: {count}\n    &lt;/button&gt;\n  );\n}\n\n// 初回マウント時:\n// 1. レンダリング\n// 2. レンダリング完了\n// 3. エフェクト実行\n\n// ボタンクリック時:\n// 1. レンダリング\n// 2. レンダリング完了\n// 2. クリーンアップ（前のエフェクトの）\n// 3. エフェクト実行</code></pre></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">localStorageとの同期</h2><p class=\"content-text\">useEffectを使って状態をlocalStorageと同期する例：</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function useLocalStorage(key, initialValue) {\n  // 初期値をlocalStorageから読み込む\n  const [value, setValue] = useState(() => {\n    const saved = localStorage.getItem(key);\n    return saved !== null ? JSON.parse(saved) : initialValue;\n  });\n\n  // 値が変わったらlocalStorageに保存\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue];\n}\n\n// 使用例\nfunction App() {\n  const [theme, setTheme] = useLocalStorage('theme', 'light');\n\n  return (\n    &lt;button onClick={() =&gt; setTheme(t =&gt; t === 'light' ? 'dark' : 'light')}&gt;\n      現在のテーマ: {theme}\n    &lt;/button&gt;\n  );\n}</code></pre></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">複数のuseEffect</h2><p class=\"content-text\">関連性のない副作用は、別々のuseEffectに分けることが推奨されます：</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function UserDashboard({ userId }) {\n  const [user, setUser] = useState(null);\n  const [posts, setPosts] = useState([]);\n\n  // ユーザー情報の取得\n  useEffect(() => {\n    fetchUser(userId).then(setUser);\n  }, [userId]);\n\n  // 投稿の取得（別の副作用）\n  useEffect(() => {\n    fetchPosts(userId).then(setPosts);\n  }, [userId]);\n\n  // ドキュメントタイトルの更新（さらに別の副作用）\n  useEffect(() => {\n    if (user) {\n      document.title = `${user.name}のダッシュボード`;\n    }\n  }, [user]);\n\n  // ...\n}</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">💡</span><div class=\"info-box-content\"><div class=\"info-box-title\">useEffectを分ける理由</div><div class=\"info-box-text\">1. 関心の分離：各エフェクトが1つの責務を持つ<br/>2. 依存配列の最適化：必要な時だけ実行される<br/>3. 可読性の向上：何をしているか分かりやすい</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">useEffectが不要なケース</h2><p class=\"content-text\">すべての処理にuseEffectが必要なわけではありません：</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// ❌ 不要なuseEffect：派生状態の計算\nfunction BadExample({ items }) {\n  const [filteredItems, setFilteredItems] = useState([]);\n  \n  useEffect(() => {\n    setFilteredItems(items.filter(item => item.active));\n  }, [items]);\n}\n\n// ✅ レンダリング中に計算すればOK\nfunction GoodExample({ items }) {\n  const filteredItems = items.filter(item => item.active);\n  // または useMemo で最適化\n  // const filteredItems = useMemo(() => items.filter(item => item.active), [items]);\n}\n\n// ❌ 不要なuseEffect：イベントハンドラで十分\nfunction BadForm() {\n  const [value, setValue] = useState('');\n  \n  useEffect(() => {\n    // valueが変わるたびにAPIを呼ぶ\n    saveToServer(value);\n  }, [value]);\n}\n\n// ✅ イベントハンドラで処理\nfunction GoodForm() {\n  const [value, setValue] = useState('');\n  \n  const handleSubmit = () => {\n    saveToServer(value);\n  };\n}</code></pre></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">まとめ</h2><p class=\"content-text\">この章で学んだこと：</p><ul><li><strong>副作用</strong> - レンダリング以外の外部システムとのやり取り</li><li><strong>useEffect</strong> - 副作用を実行するためのHook</li><li><strong>依存配列</strong> - エフェクトの実行タイミングを制御</li><li><strong>クリーンアップ関数</strong> - 副作用の後始末を行う</li><li><strong>データフェッチング</strong> - async/awaitとレースコンディション対策</li><li><strong>無限ループ</strong> - 依存配列と状態更新の関係に注意</li></ul><p class=\"content-text\">次のレッスンでは、<strong>イベント処理とフォーム</strong>について学びます。</p></div>",
  "exercises": [
    {
      "question": "useEffectの依存配列が空配列 [] の場合、エフェクトはいつ実行されますか？",
      "options": [
        "毎回のレンダリング後に実行される",
        "コンポーネントのマウント時に1回だけ実行される",
        "状態が変更されるたびに実行される",
        "エフェクトは実行されない"
      ],
      "answer": 1,
      "explanation": "依存配列が空配列 [] の場合、エフェクトはコンポーネントがマウントされた時に1回だけ実行されます。これは、依存する値がないため、再実行の必要がないことを意味します。"
    },
    {
      "question": "useEffectのクリーンアップ関数が実行されるタイミングはどれですか？",
      "options": [
        "コンポーネントがマウントされた直後",
        "エフェクトが実行される前",
        "コンポーネントがアンマウントされる時、または次のエフェクト実行前",
        "状態が更新された直後"
      ],
      "answer": 2,
      "explanation": "クリーンアップ関数は、コンポーネントがアンマウントされる時と、依存配列の値が変わって次のエフェクトが実行される前に呼ばれます。これにより、古いエフェクトの後始末ができます。"
    },
    {
      "question": "useEffectで無限ループが発生する原因として正しいものはどれですか？",
      "options": [
        "依存配列を省略した場合",
        "エフェクト内で依存配列に含まれる状態を更新した場合",
        "クリーンアップ関数を返さなかった場合",
        "async関数を直接useEffectに渡した場合"
      ],
      "answer": 1,
      "explanation": "エフェクト内で依存配列に含まれる状態を更新すると、状態更新→再レンダリング→エフェクト実行→状態更新...という無限ループが発生します。依存配列の設計には注意が必要です。"
    },
    {
      "question": "useEffect内でasync/awaitを使う正しい方法はどれですか？",
      "options": [
        "useEffect(async () => { await fetchData(); }, [])",
        "useEffect(() => { async function fetch() { await fetchData(); } fetch(); }, [])",
        "await useEffect(() => { fetchData(); }, [])",
        "useEffect(() => { return async () => { await fetchData(); }; }, [])"
      ],
      "answer": 1,
      "explanation": "useEffectのコールバック関数自体をasyncにすることはできません（Promiseを返してしまうため）。代わりに、エフェクト内でasync関数を定義して即座に呼び出すパターンを使います。"
    }
  ]
}