{
  "id": "react-jsx",
  "category": "react",
  "title": "JSX構文",
  "description": "JSXの基本ルール、条件付きレンダリング、リストレンダリング、フラグメント、スタイル適用方法を学びましょう",
  "content": "<div class=\"content-section\"><h2 class=\"section-title\">JSXとは何か？</h2><p class=\"content-text\"><strong>JSX（JavaScript XML）</strong>は、JavaScriptの中でHTMLライクな構文を書けるようにする拡張構文です。Reactでは、UIの構造を直感的に記述するためにJSXを使用します。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// JSXの例\nconst element = &lt;h1&gt;Hello, React!&lt;/h1&gt;;\n\n// これは以下のJavaScriptに変換される\nconst element = React.createElement('h1', null, 'Hello, React!');</code></pre></div></div><p class=\"content-text\">JSXは必須ではありませんが、視覚的にわかりやすく、多くのReact開発者が使用しています。</p><div class=\"info-box\"><span class=\"info-box-icon\">💡</span><div class=\"info-box-content\"><div class=\"info-box-title\">ポイント</div><div class=\"info-box-text\">JSXはブラウザが直接理解できないため、BabelなどのトランスパイラでJavaScriptに変換されます。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">JSXの基本ルール</h2><p class=\"content-text\">JSXを書く際には、いくつかの重要なルールがあります。</p><h3>1. 単一の親要素で囲む</h3><p class=\"content-text\">JSXは必ず<strong>1つの親要素</strong>で囲む必要があります。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// ❌ エラー：複数の要素を返せない\nreturn (\n  &lt;h1&gt;タイトル&lt;/h1&gt;\n  &lt;p&gt;説明文&lt;/p&gt;\n);\n\n// ✅ OK：divで囲む\nreturn (\n  &lt;div&gt;\n    &lt;h1&gt;タイトル&lt;/h1&gt;\n    &lt;p&gt;説明文&lt;/p&gt;\n  &lt;/div&gt;\n);</code></pre></div></div><h3>2. classNameを使う</h3><p class=\"content-text\">HTMLの<code>class</code>属性は、JSXでは<code>className</code>を使います。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// ❌ HTMLの書き方\n&lt;div class=\"container\"&gt;...&lt;/div&gt;\n\n// ✅ JSXの書き方\n&lt;div className=\"container\"&gt;...&lt;/div&gt;</code></pre></div></div><h3>3. {}で式を埋め込む</h3><p class=\"content-text\">JavaScript式は<code>{}</code>（波括弧）で囲んで埋め込みます。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>const name = 'React';\nconst count = 42;\n\nreturn (\n  &lt;div&gt;\n    &lt;h1&gt;Hello, {name}!&lt;/h1&gt;\n    &lt;p&gt;カウント: {count}&lt;/p&gt;\n    &lt;p&gt;計算結果: {10 + 20}&lt;/p&gt;\n    &lt;p&gt;現在時刻: {new Date().toLocaleTimeString()}&lt;/p&gt;\n  &lt;/div&gt;\n);</code></pre></div></div><h3>4. 自己終了タグ</h3><p class=\"content-text\">子要素を持たない要素は、自己終了タグで書きます。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// ✅ 自己終了タグ\n&lt;img src=\"image.png\" alt=\"画像\" /&gt;\n&lt;input type=\"text\" /&gt;\n&lt;br /&gt;\n&lt;MyComponent /&gt;</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">⚠️</span><div class=\"info-box-content\"><div class=\"info-box-title\">注意</div><div class=\"info-box-text\">JSXでは、すべてのタグを閉じる必要があります。HTMLでは省略できる&lt;br&gt;や&lt;img&gt;も、JSXでは&lt;br /&gt;や&lt;img /&gt;と書きます。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">条件付きレンダリング</h2><p class=\"content-text\">Reactでは、条件に応じて異なるUIを表示できます。いくつかのパターンを見てみましょう。</p><h3>1. &&演算子（論理AND）</h3><p class=\"content-text\">条件がtrueの場合のみ要素を表示します。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function Notification({ hasMessage }) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;ダッシュボード&lt;/h1&gt;\n      {hasMessage && &lt;p&gt;新しいメッセージがあります！&lt;/p&gt;}\n    &lt;/div&gt;\n  );\n}</code></pre></div></div><h3>2. 三項演算子</h3><p class=\"content-text\">条件によって2つの要素を切り替えます。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function LoginButton({ isLoggedIn }) {\n  return (\n    &lt;div&gt;\n      {isLoggedIn \n        ? &lt;button&gt;ログアウト&lt;/button&gt; \n        : &lt;button&gt;ログイン&lt;/button&gt;\n      }\n    &lt;/div&gt;\n  );\n}</code></pre></div></div><h3>3. 早期return</h3><p class=\"content-text\">条件を満たさない場合に早めにreturnします。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function UserProfile({ user }) {\n  // userがない場合は早期return\n  if (!user) {\n    return &lt;p&gt;ユーザーが見つかりません&lt;/p&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;{user.name}&lt;/h2&gt;\n      &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">💡</span><div class=\"info-box-content\"><div class=\"info-box-title\">使い分けのコツ</div><div class=\"info-box-text\">表示/非表示の切り替えには&&、2択の切り替えには三項演算子、複雑な条件には早期returnが適しています。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">リストのレンダリング</h2><p class=\"content-text\">配列データをUIに表示するには、<code>map()</code>メソッドを使います。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function TodoList() {\n  const todos = [\n    { id: 1, text: '買い物に行く' },\n    { id: 2, text: 'レポートを書く' },\n    { id: 3, text: 'Reactを学ぶ' },\n  ];\n\n  return (\n    &lt;ul&gt;\n      {todos.map(todo =&gt; (\n        &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}</code></pre></div></div><h3>key属性の重要性</h3><p class=\"content-text\"><code>key</code>属性は、Reactがリスト内の各要素を識別するために必要です。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// ✅ 良い例：一意のIDをkeyに使用\n{items.map(item =&gt; (\n  &lt;Item key={item.id} data={item} /&gt;\n))}\n\n// ❌ 悪い例：インデックスをkeyに使用（並び替えで問題が起きる）\n{items.map((item, index) =&gt; (\n  &lt;Item key={index} data={item} /&gt;\n))}</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">⚠️</span><div class=\"info-box-content\"><div class=\"info-box-title\">keyのルール</div><div class=\"info-box-text\">keyは兄弟要素間で一意である必要があります。配列のインデックスは、要素の追加・削除・並び替えがある場合に問題を引き起こすため、避けましょう。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">フラグメント（Fragment）</h2><p class=\"content-text\">複数の要素を返したいが、余分なDOMノードを追加したくない場合は<strong>フラグメント</strong>を使います。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>import { Fragment } from 'react';\n\n// 方法1: React.Fragment\nfunction TableRow() {\n  return (\n    &lt;Fragment&gt;\n      &lt;td&gt;セル1&lt;/td&gt;\n      &lt;td&gt;セル2&lt;/td&gt;\n    &lt;/Fragment&gt;\n  );\n}\n\n// 方法2: 短縮構文 &lt;&gt;...&lt;/&gt;（推奨）\nfunction TableRow() {\n  return (\n    &lt;&gt;\n      &lt;td&gt;セル1&lt;/td&gt;\n      &lt;td&gt;セル2&lt;/td&gt;\n    &lt;/&gt;\n  );\n}</code></pre></div></div><p class=\"content-text\">フラグメントを使うと、不要な<code>&lt;div&gt;</code>を避けられます：</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">比較</span></div><div class=\"code-content\"><pre><code>// divを使った場合のDOM\n&lt;div&gt;\n  &lt;td&gt;セル1&lt;/td&gt;\n  &lt;td&gt;セル2&lt;/td&gt;\n&lt;/div&gt;  ← 余分なdivが入る（テーブル構造が壊れる）\n\n// フラグメントを使った場合のDOM\n&lt;td&gt;セル1&lt;/td&gt;\n&lt;td&gt;セル2&lt;/td&gt;  ← 余分な要素なし</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">💡</span><div class=\"info-box-content\"><div class=\"info-box-title\">keyが必要な場合</div><div class=\"info-box-text\">リスト内でフラグメントを使う場合は、短縮構文ではなく&lt;Fragment key={id}&gt;を使用します。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">スタイルの適用方法</h2><p class=\"content-text\">Reactでは、いくつかの方法でスタイルを適用できます。</p><h3>1. インラインスタイル</h3><p class=\"content-text\">JavaScriptオブジェクトでスタイルを指定します。プロパティ名はキャメルケースで書きます。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function StyledComponent() {\n  const style = {\n    backgroundColor: 'blue',  // background-color → backgroundColor\n    color: 'white',\n    padding: '10px 20px',\n    borderRadius: '8px',      // border-radius → borderRadius\n    fontSize: '16px',         // font-size → fontSize\n  };\n\n  return &lt;button style={style}&gt;クリック&lt;/button&gt;;\n}\n\n// 直接書くこともできる\n&lt;div style={{ marginTop: '20px', display: 'flex' }}&gt;...&lt;/div&gt;</code></pre></div></div><h3>2. CSSファイルのインポート</h3><p class=\"content-text\">通常のCSSファイルをインポートして使用します。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// App.jsx\nimport './App.css';\n\nfunction App() {\n  return &lt;div className=\"container\"&gt;...&lt;/div&gt;;\n}</code></pre></div></div><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">CSS</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>/* App.css */\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n}</code></pre></div></div><h3>3. CSS Modules</h3><p class=\"content-text\">CSS Modulesを使うと、クラス名が自動的にユニークになり、スタイルの衝突を防げます。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>// Button.jsx\nimport styles from './Button.module.css';\n\nfunction Button() {\n  return (\n    &lt;button className={styles.primary}&gt;\n      クリック\n    &lt;/button&gt;\n  );\n}</code></pre></div></div><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">CSS</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>/* Button.module.css */\n.primary {\n  background-color: #007bff;\n  color: white;\n  border: none;\n  padding: 10px 20px;\n}</code></pre></div></div><div class=\"info-box\"><span class=\"info-box-icon\">💡</span><div class=\"info-box-content\"><div class=\"info-box-title\">スタイル方法の選び方</div><div class=\"info-box-text\">動的なスタイルにはインラインスタイル、コンポーネント固有のスタイルにはCSS Modules、グローバルなスタイルには通常のCSSファイルが適しています。</div></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">動的なクラス名</h2><p class=\"content-text\">条件に応じてクラス名を切り替える方法です。</p><div class=\"code-block\"><div class=\"code-header\"><span class=\"code-lang\">JSX</span><button class=\"code-copy\" onclick=\"copyCode(this)\">コピー</button></div><div class=\"code-content\"><pre><code>function Button({ isActive, isDisabled }) {\n  // テンプレートリテラルで結合\n  const className = `btn ${isActive ? 'btn-active' : ''} ${isDisabled ? 'btn-disabled' : ''}`;\n  \n  return &lt;button className={className}&gt;ボタン&lt;/button&gt;;\n}\n\n// 配列とfilter/joinを使う方法\nfunction Button({ isActive, isDisabled }) {\n  const classes = [\n    'btn',\n    isActive && 'btn-active',\n    isDisabled && 'btn-disabled',\n  ].filter(Boolean).join(' ');\n  \n  return &lt;button className={classes}&gt;ボタン&lt;/button&gt;;\n}</code></pre></div></div></div><div class=\"content-section\"><h2 class=\"section-title\">まとめ</h2><p class=\"content-text\">この章で学んだこと：</p><ul><li><strong>JSX</strong>はJavaScript内でHTMLライクな構文を書ける拡張</li><li><strong>基本ルール</strong>：単一親要素、className、{}での式埋め込み、自己終了タグ</li><li><strong>条件付きレンダリング</strong>：&&、三項演算子、早期return</li><li><strong>リストレンダリング</strong>：map()とkey属性</li><li><strong>フラグメント</strong>：&lt;&gt;...&lt;/&gt;で余分なDOMを避ける</li><li><strong>スタイル適用</strong>：インラインスタイル、CSSファイル、CSS Modules</li></ul><p class=\"content-text\">次のレッスンでは、Reactの核となる<strong>コンポーネントとProps</strong>について詳しく学びます。</p></div>",
  "exercises": [
    {
      "question": "JSXで複数の要素を返す際に、余分なDOMノードを追加せずに囲む方法はどれですか？",
      "options": [
        "<div>で囲む",
        "<span>で囲む",
        "<>...</>（フラグメント）で囲む",
        "<section>で囲む"
      ],
      "answer": 2,
      "explanation": "フラグメント（<>...</>または<Fragment>）を使うと、余分なDOMノードを追加せずに複数の要素をグループ化できます。divやspanで囲むと、実際のDOMに余分な要素が追加されます。"
    },
    {
      "question": "JSXでリストをレンダリングする際、key属性について正しい説明はどれですか？",
      "options": [
        "keyは省略可能で、パフォーマンスには影響しない",
        "keyには常に配列のインデックスを使うべき",
        "keyは兄弟要素間で一意である必要があり、要素の識別に使われる",
        "keyはCSSのスタイリングに使用される"
      ],
      "answer": 2,
      "explanation": "key属性はReactがリスト内の各要素を識別するために必要です。兄弟要素間で一意である必要があり、要素の追加・削除・並び替え時に正しく更新するために使われます。インデックスは並び替えで問題が起きるため、一意のIDを使うべきです。"
    },
    {
      "question": "JSXでインラインスタイルを適用する際、正しい書き方はどれですか？",
      "options": [
        "style=\"background-color: blue\"",
        "style={{ backgroundColor: 'blue' }}",
        "style={background-color: blue}",
        "className={{ backgroundColor: 'blue' }}"
      ],
      "answer": 1,
      "explanation": "JSXのインラインスタイルはJavaScriptオブジェクトで指定します。プロパティ名はキャメルケース（backgroundColor）で書き、値は文字列で指定します。二重の波括弧は、外側がJSX式、内側がオブジェクトリテラルを表します。"
    },
    {
      "question": "JSXで条件付きレンダリングを行う際、「条件がtrueの場合のみ要素を表示する」のに最適な方法はどれですか？",
      "options": [
        "if文を使う",
        "&&演算子を使う",
        "switch文を使う",
        "for文を使う"
      ],
      "answer": 1,
      "explanation": "&&演算子（論理AND）は、左側の条件がtrueの場合のみ右側の要素を表示します。例：{isLoggedIn && <p>ようこそ</p>}。シンプルな表示/非表示の切り替えに最適です。"
    }
  ]
}